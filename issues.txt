layer z_depth if changed manually doesn't work then

https://github.com/synfig/synfig/commit/b7d65c142a20381da3396fffb42e1440a218e576

TANGENT_FACTOR optimal: https://github.com/synfig/synfig/blob/master/ETL/ETL/_hermite.h
LOttie calculates bezier as: https://github.com/airbnb/lottie-web/blob/master/player/js/utils/PropertyFactory.js
https://lottiefiles.com/user/67632
Use Repeater of Adobe after effects in Duplicate layer of Synfig

Next GSOC Mentor Idea: 
-> Convert lottie(.json) format to .sif format
-> implement the convert methods present in animation in synfig
-> Generate color for each frame in case of bezier interpolation
-> Might be helpful at the end of GSOC: https://github.com/airbnb/lottie-web/issues/1614

TODOS:
Function documentation: https://sphinxcontrib-napoleon.readthedocs.io/en/latest/example_google.html
Documentation: https://www.tablesgenerator.com/text_tables
Logger and Logging information to know which layer we can't parse
TCB values for inserted waypoints need to be determined: Improvement:- For now average of tcb is taken
[Later, Not a need now]Make a wrapper for finding vector at time t for waypoint such that, if not animated: make it animated inside that first function itselves
Define operator [] on class misc.Vector


Inner Radius - Polygon interpolation problem:
-> perpendicular distance in polygon = or*Cos(theta/2)
    -> Finding this will depend upon the number of points
    -> If number of points is chaning somewhere in the animation, then more waypoints need to be introduced
    -> For simplicity, assume that number of points is not changing yet
        -> After this deal with difficult problem of `changing number of points of star`
-> Never consider it as a polygon, always make inner radius equal to the above given value
    -> To do this, will have to implement the tcb value finder in python
    -> To find subsection of bezier: https://math.stackexchange.com/questions/317806/equation-for-subsection-of-bezier-curve
    -> Waypoint not always starts from zero, so take the value from it's first waypoint
    -> Inner radius needs to be changed as many times as needed according to the outer radius

    False -> True (all area in between is covered) [Only the starting frame remains false]
    True -> False (all area again is covered) [Only the ending frame remains false]
    False -> False (all area in between remains false)
    True -> True (all area in between remains true)

    Hence our favourable area will be:
    example: false false false true true true true true false false
                         ------------------------------------
    All the dashed part should be considered as polygon
    -> All neighbouring false's and true's will be collapsed into a single entity, and they will be operated on
